{"ast":null,"code":"'use strict';\n/*\n * Engines which do not support caching of their file contents\n * should use the `read()` function defined in consolidate.js\n * On top of this, when an engine compiles to a `Function`,\n * these functions should either be cached within consolidate.js\n * or the engine itself via `options.cache`. This will allow\n * users and frameworks to pass `options.cache = true` for\n * `NODE_ENV=production`, however edit the file(s) without\n * re-loading the application in development.\n */\n\n/**\n * Module dependencies.\n */\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar Promise = require('bluebird');\n\nvar join = path.join;\nvar resolve = path.resolve;\nvar extname = path.extname;\nvar dirname = path.dirname;\nvar isAbsolute = path.isAbsolute;\nvar readCache = {};\n/**\n * Require cache.\n */\n\nvar cacheStore = {};\n/**\n * Require cache.\n */\n\nvar requires = {};\n/**\n * Clear the cache.\n *\n * @api public\n */\n\nexports.clearCache = function () {\n  readCache = {};\n  cacheStore = {};\n};\n/**\n * Conditionally cache `compiled` template based\n * on the `options` filename and `.cache` boolean.\n *\n * @param {Object} options\n * @param {Function} compiled\n * @return {Function}\n * @api private\n */\n\n\nfunction cache(options, compiled) {\n  // cachable\n  if (compiled && options.filename && options.cache) {\n    delete readCache[options.filename];\n    cacheStore[options.filename] = compiled;\n    return compiled;\n  } // check cache\n\n\n  if (options.filename && options.cache) {\n    return cacheStore[options.filename];\n  }\n\n  return compiled;\n}\n/**\n * Read `path` with `options` with\n * callback `(err, str)`. When `options.cache`\n * is true the template string will be cached.\n *\n * @param {String} options\n * @param {Function} cb\n * @api private\n */\n\n\nfunction read(path, options, cb) {\n  var str = readCache[path];\n  var cached = options.cache && str && typeof str === 'string'; // cached (only if cached is a string and not a compiled template function)\n\n  if (cached) return cb(null, str); // read\n\n  fs.readFile(path, 'utf8', function (err, str) {\n    if (err) return cb(err); // remove extraneous utf8 BOM marker\n\n    str = str.replace(/^\\uFEFF/, '');\n    if (options.cache) readCache[path] = str;\n    cb(null, str);\n  });\n}\n/**\n * Read `path` with `options` with\n * callback `(err, str)`. When `options.cache`\n * is true the partial string will be cached.\n *\n * @param {String} options\n * @param {Function} fn\n * @api private\n */\n\n\nfunction readPartials(path, options, cb) {\n  if (!options.partials) return cb();\n  var partials = options.partials;\n  var keys = Object.keys(partials);\n\n  function next(index) {\n    if (index === keys.length) return cb(null);\n    var key = keys[index];\n    var partialPath = partials[key];\n\n    if (partialPath === undefined || partialPath === null || partialPath === false) {\n      return next(++index);\n    }\n\n    var file;\n\n    if (isAbsolute(partialPath)) {\n      if (extname(partialPath) !== '') {\n        file = partialPath;\n      } else {\n        file = join(partialPath + extname(path));\n      }\n    } else {\n      file = join(dirname(path), partialPath + extname(path));\n    }\n\n    read(file, options, function (err, str) {\n      if (err) return cb(err);\n      options.partials[key] = str;\n      next(++index);\n    });\n  }\n\n  next(0);\n}\n/**\n * promisify\n */\n\n\nfunction promisify(cb, fn) {\n  return new Promise(function (resolve, reject) {\n    cb = cb || function (err, html) {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve(html);\n    };\n\n    fn(cb);\n  });\n}\n/**\n * fromStringRenderer\n */\n\n\nfunction fromStringRenderer(name) {\n  return function (path, options, cb) {\n    options.filename = path;\n    return promisify(cb, function (cb) {\n      readPartials(path, options, function (err) {\n        if (err) return cb(err);\n\n        if (cache(options)) {\n          exports[name].render('', options, cb);\n        } else {\n          read(path, options, function (err, str) {\n            if (err) return cb(err);\n            exports[name].render(str, options, cb);\n          });\n        }\n      });\n    });\n  };\n}\n/**\n * velocity support.\n */\n\n\nexports.velocityjs = fromStringRenderer('velocityjs');\n/**\n * velocity string support.\n */\n\nexports.velocityjs.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.velocityjs || (requires.velocityjs = require('velocityjs'));\n\n    try {\n      options.locals = options;\n      cb(null, engine.render(str, options).trimLeft());\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Liquid support.\n */\n\n\nexports.liquid = fromStringRenderer('liquid');\n/**\n * Liquid string support.\n */\n\n/**\n * Note that in order to get filters and custom tags we've had to push\n * all user-defined locals down into @locals. However, just to make things\n * backwards-compatible, any property of `options` that is left after\n * processing and removing `locals`, `meta`, `filters`, `customTags` and\n * `includeDir` will also become a local.\n */\n\nfunction _renderTinyliquid(engine, str, options, cb) {\n  var context = engine.newContext();\n  var k;\n  /**\n   * Note that there's a bug in the library that doesn't allow us to pass\n   * the locals to newContext(), hence looping through the keys:\n   */\n\n  if (options.locals) {\n    for (k in options.locals) {\n      context.setLocals(k, options.locals[k]);\n    }\n\n    delete options.locals;\n  }\n\n  if (options.meta) {\n    context.setLocals('page', options.meta);\n    delete options.meta;\n  }\n  /**\n   * Add any defined filters:\n   */\n\n\n  if (options.filters) {\n    for (k in options.filters) {\n      context.setFilter(k, options.filters[k]);\n    }\n\n    delete options.filters;\n  }\n  /**\n   * Set up a callback for the include directory:\n   */\n\n\n  var includeDir = options.includeDir || process.cwd();\n  context.onInclude(function (name, callback) {\n    var extname = path.extname(name) ? '' : '.liquid';\n    var filename = path.resolve(includeDir, name + extname);\n    fs.readFile(filename, {\n      encoding: 'utf8'\n    }, function (err, data) {\n      if (err) return callback(err);\n      callback(null, engine.parse(data));\n    });\n  });\n  delete options.includeDir;\n  /**\n   * The custom tag functions need to have their results pushed back\n   * through the parser, so set up a shim before calling the provided\n   * callback:\n   */\n\n  var compileOptions = {\n    customTags: {}\n  };\n\n  if (options.customTags) {\n    var tagFunctions = options.customTags;\n\n    for (k in options.customTags) {\n      /*Tell jshint there's no problem with having this function in the loop */\n\n      /*jshint -W083 */\n      compileOptions.customTags[k] = function (context, name, body) {\n        var tpl = tagFunctions[name](body.trim());\n        context.astStack.push(engine.parse(tpl));\n      };\n      /*jshint +W083 */\n\n    }\n\n    delete options.customTags;\n  }\n  /**\n   * Now anything left in `options` becomes a local:\n   */\n\n\n  for (k in options) {\n    context.setLocals(k, options[k]);\n  }\n  /**\n   * Finally, execute the template:\n   */\n\n\n  var tmpl = cache(context) || cache(context, engine.compile(str, compileOptions));\n  tmpl(context, cb);\n}\n\nexports.liquid.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.liquid;\n    var Liquid;\n\n    try {\n      // set up tinyliquid engine\n      engine = requires.liquid = require('tinyliquid'); // use tinyliquid engine\n\n      _renderTinyliquid(engine, str, options, cb);\n\n      return;\n    } catch (err) {\n      // set up liquid-node engine\n      try {\n        Liquid = requires.liquid = require('liquid-node');\n        engine = new Liquid.Engine();\n      } catch (err) {\n        throw err;\n      }\n    } // use liquid-node engine\n\n\n    try {\n      var locals = options.locals || {};\n\n      if (options.meta) {\n        locals.pages = options.meta;\n        delete options.meta;\n      }\n      /**\n       * Add any defined filters:\n       */\n\n\n      if (options.filters) {\n        engine.registerFilters(options.filters);\n        delete options.filters;\n      }\n      /**\n       * Set up a callback for the include directory:\n       */\n\n\n      var includeDir = options.includeDir || process.cwd();\n      engine.fileSystem = new Liquid.LocalFileSystem(includeDir, 'liquid');\n      delete options.includeDir;\n      /**\n       * The custom tag functions need to have their results pushed back\n       * through the parser, so set up a shim before calling the provided\n       * callback:\n       */\n\n      if (options.customTags) {\n        var tagFunctions = options.customTags;\n\n        for (k in options.customTags) {\n          engine.registerTag(k, tagFunctions[k]);\n        }\n\n        delete options.customTags;\n      }\n      /**\n       * Now anything left in `options` becomes a local:\n       */\n\n\n      for (var k in options) {\n        locals[k] = options[k];\n      }\n      /**\n       * Finally, execute the template:\n       */\n\n\n      return engine.parseAndRender(str, locals).nodeify(function (err, result) {\n        if (err) {\n          throw new Error(err);\n        } else {\n          return cb(null, result);\n        }\n      });\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Jade support.\n */\n\n\nexports.jade = function (path, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.jade;\n\n    if (!engine) {\n      try {\n        engine = requires.jade = require('jade');\n      } catch (err) {\n        try {\n          engine = requires.jade = require('then-jade');\n        } catch (otherError) {\n          throw err;\n        }\n      }\n    }\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.compileFile(path, options));\n      cb(null, tmpl(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Jade string support.\n */\n\n\nexports.jade.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.jade;\n\n    if (!engine) {\n      try {\n        engine = requires.jade = require('jade');\n      } catch (err) {\n        try {\n          engine = requires.jade = require('then-jade');\n        } catch (otherError) {\n          throw err;\n        }\n      }\n    }\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.compile(str, options));\n      cb(null, tmpl(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Dust support.\n */\n\n\nexports.dust = fromStringRenderer('dust');\n/**\n * Dust string support.\n */\n\nexports.dust.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.dust;\n\n    if (!engine) {\n      try {\n        engine = requires.dust = require('dust');\n      } catch (err) {\n        try {\n          engine = requires.dust = require('dustjs-helpers');\n        } catch (err) {\n          engine = requires.dust = require('dustjs-linkedin');\n        }\n      }\n    }\n\n    var ext = 'dust';\n    var views = '.';\n\n    if (options) {\n      if (options.ext) ext = options.ext;\n      if (options.views) views = options.views;\n      if (options.settings && options.settings.views) views = options.settings.views;\n    }\n\n    if (!options || options && !options.cache) engine.cache = {};\n\n    engine.onLoad = function (path, callback) {\n      if (extname(path) === '') path += '.' + ext;\n      if (path[0] !== '/') path = views + '/' + path;\n      read(path, options, callback);\n    };\n\n    try {\n      var templateName;\n\n      if (options.filename) {\n        templateName = options.filename.replace(new RegExp('^' + views + '/'), '').replace(new RegExp('\\\\.' + ext), '');\n      }\n\n      var tmpl = cache(options) || cache(options, engine.compileFn(str, templateName));\n      tmpl(options, cb);\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Swig support.\n */\n\n\nexports.swig = fromStringRenderer('swig');\n/**\n * Swig string support.\n */\n\nexports.swig.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.swig;\n\n    if (!engine) {\n      try {\n        engine = requires.swig = require('swig');\n      } catch (err) {\n        try {\n          engine = requires.swig = require('swig-templates');\n        } catch (otherError) {\n          throw err;\n        }\n      }\n    }\n\n    try {\n      if (options.cache === true) options.cache = 'memory';\n      engine.setDefaults({\n        cache: options.cache\n      });\n      var tmpl = cache(options) || cache(options, engine.compile(str, options));\n      cb(null, tmpl(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Atpl support.\n */\n\n\nexports.atpl = fromStringRenderer('atpl');\n/**\n * Atpl string support.\n */\n\nexports.atpl.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.atpl || (requires.atpl = require('atpl'));\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.compile(str, options));\n      cb(null, tmpl(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Liquor support,\n */\n\n\nexports.liquor = fromStringRenderer('liquor');\n/**\n * Liquor string support.\n */\n\nexports.liquor.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.liquor || (requires.liquor = require('liquor'));\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.compile(str, options));\n      cb(null, tmpl(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Twig support.\n */\n\n\nexports.twig = fromStringRenderer('twig');\n/**\n * Twig string support.\n */\n\nexports.twig.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.twig || (requires.twig = require('twig').twig);\n\n    var templateData = {\n      data: str\n    };\n\n    try {\n      var tmpl = cache(templateData) || cache(templateData, engine(templateData));\n      cb(null, tmpl.render(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * EJS support.\n */\n\n\nexports.ejs = fromStringRenderer('ejs');\n/**\n * EJS string support.\n */\n\nexports.ejs.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.ejs || (requires.ejs = require('ejs'));\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.compile(str, options));\n      cb(null, tmpl(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Eco support.\n */\n\n\nexports.eco = fromStringRenderer('eco');\n/**\n * Eco string support.\n */\n\nexports.eco.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.eco || (requires.eco = require('eco'));\n\n    try {\n      cb(null, engine.render(str, options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Jazz support.\n */\n\n\nexports.jazz = fromStringRenderer('jazz');\n/**\n * Jazz string support.\n */\n\nexports.jazz.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.jazz || (requires.jazz = require('jazz'));\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.compile(str, options));\n      tmpl.eval(options, function (str) {\n        cb(null, str);\n      });\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * JQTPL support.\n */\n\n\nexports.jqtpl = fromStringRenderer('jqtpl');\n/**\n * JQTPL string support.\n */\n\nexports.jqtpl.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.jqtpl || (requires.jqtpl = require('jqtpl'));\n\n    try {\n      engine.template(str, str);\n      cb(null, engine.tmpl(str, options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Haml support.\n */\n\n\nexports.haml = fromStringRenderer('haml');\n/**\n * Haml string support.\n */\n\nexports.haml.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.haml || (requires.haml = require('hamljs'));\n\n    try {\n      options.locals = options;\n      cb(null, engine.render(str, options).trimLeft());\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Hamlet support.\n */\n\n\nexports.hamlet = fromStringRenderer('hamlet');\n/**\n * Hamlet string support.\n */\n\nexports.hamlet.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.hamlet || (requires.hamlet = require('hamlet'));\n\n    try {\n      options.locals = options;\n      cb(null, engine.render(str, options).trimLeft());\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Whiskers support.\n */\n\n\nexports.whiskers = function (path, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.whiskers || (requires.whiskers = require('whiskers'));\n\n    engine.__express(path, options, cb);\n  });\n};\n/**\n * Whiskers string support.\n */\n\n\nexports.whiskers.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.whiskers || (requires.whiskers = require('whiskers'));\n\n    try {\n      cb(null, engine.render(str, options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Coffee-HAML support.\n */\n\n\nexports['haml-coffee'] = fromStringRenderer('haml-coffee');\n/**\n * Coffee-HAML string support.\n */\n\nexports['haml-coffee'].render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires['haml-coffee'] || (requires['haml-coffee'] = require('haml-coffee'));\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.compile(str, options));\n      cb(null, tmpl(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Hogan support.\n */\n\n\nexports.hogan = fromStringRenderer('hogan');\n/**\n * Hogan string support.\n */\n\nexports.hogan.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.hogan || (requires.hogan = require('hogan.js'));\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.compile(str, options));\n      cb(null, tmpl.render(options, options.partials));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * templayed.js support.\n */\n\n\nexports.templayed = fromStringRenderer('templayed');\n/**\n * templayed.js string support.\n */\n\nexports.templayed.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.templayed || (requires.templayed = require('templayed'));\n\n    try {\n      var tmpl = cache(options) || cache(options, engine(str));\n      cb(null, tmpl(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Handlebars support.\n */\n\n\nexports.handlebars = fromStringRenderer('handlebars');\n/**\n * Handlebars string support.\n */\n\nexports.handlebars.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.handlebars || (requires.handlebars = require('handlebars'));\n\n    try {\n      for (var partial in options.partials) {\n        engine.registerPartial(partial, options.partials[partial]);\n      }\n\n      for (var helper in options.helpers) {\n        engine.registerHelper(helper, options.helpers[helper]);\n      }\n\n      var tmpl = cache(options) || cache(options, engine.compile(str, options));\n      cb(null, tmpl(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Underscore support.\n */\n\n\nexports.underscore = fromStringRenderer('underscore');\n/**\n * Underscore string support.\n */\n\nexports.underscore.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.underscore || (requires.underscore = require('underscore'));\n\n    try {\n      for (var partial in options.partials) {\n        options.partials[partial] = engine.template(options.partials[partial]);\n      }\n\n      var tmpl = cache(options) || cache(options, engine.template(str, null, options));\n      cb(null, tmpl(options).replace(/\\n$/, ''));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Lodash support.\n */\n\n\nexports.lodash = fromStringRenderer('lodash');\n/**\n * Lodash string support.\n */\n\nexports.lodash.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.lodash || (requires.lodash = require('lodash'));\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.template(str, options));\n      cb(null, tmpl(options).replace(/\\n$/, ''));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Pug support. (formerly Jade)\n */\n\n\nexports.pug = function (path, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.pug;\n\n    if (!engine) {\n      try {\n        engine = requires.pug = require('pug');\n      } catch (err) {\n        try {\n          engine = requires.pug = require('then-pug');\n        } catch (otherError) {\n          throw err;\n        }\n      }\n    }\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.compileFile(path, options));\n      cb(null, tmpl(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Pug string support.\n */\n\n\nexports.pug.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.pug;\n\n    if (!engine) {\n      try {\n        engine = requires.pug = require('pug');\n      } catch (err) {\n        try {\n          engine = requires.pug = require('then-pug');\n        } catch (otherError) {\n          throw err;\n        }\n      }\n    }\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.compile(str, options));\n      cb(null, tmpl(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * QEJS support.\n */\n\n\nexports.qejs = fromStringRenderer('qejs');\n/**\n * QEJS string support.\n */\n\nexports.qejs.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    try {\n      var engine = requires.qejs || (requires.qejs = require('qejs'));\n\n      engine.render(str, options).then(function (result) {\n        cb(null, result);\n      }, function (err) {\n        cb(err);\n      }).done();\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Walrus support.\n */\n\n\nexports.walrus = fromStringRenderer('walrus');\n/**\n * Walrus string support.\n */\n\nexports.walrus.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.walrus || (requires.walrus = require('walrus'));\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.parse(str));\n      cb(null, tmpl.compile(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Mustache support.\n */\n\n\nexports.mustache = fromStringRenderer('mustache');\n/**\n * Mustache string support.\n */\n\nexports.mustache.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.mustache || (requires.mustache = require('mustache'));\n\n    try {\n      cb(null, engine.to_html(str, options, options.partials));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Just support.\n */\n\n\nexports.just = function (path, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.just;\n\n    if (!engine) {\n      var JUST = require('just');\n\n      engine = requires.just = new JUST();\n    }\n\n    engine.configure({\n      useCache: options.cache\n    });\n    engine.render(path, options, cb);\n  });\n};\n/**\n * Just string support.\n */\n\n\nexports.just.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var JUST = require('just');\n\n    var engine = new JUST({\n      root: {\n        page: str\n      }\n    });\n    engine.render('page', options, cb);\n  });\n};\n/**\n * ECT support.\n */\n\n\nexports.ect = function (path, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.ect;\n\n    if (!engine) {\n      var ECT = require('ect');\n\n      engine = requires.ect = new ECT(options);\n    }\n\n    engine.configure({\n      cache: options.cache\n    });\n    engine.render(path, options, cb);\n  });\n};\n/**\n * ECT string support.\n */\n\n\nexports.ect.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var ECT = require('ect');\n\n    var engine = new ECT({\n      root: {\n        page: str\n      }\n    });\n    engine.render('page', options, cb);\n  });\n};\n/**\n * mote support.\n */\n\n\nexports.mote = fromStringRenderer('mote');\n/**\n * mote string support.\n */\n\nexports.mote.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.mote || (requires.mote = require('mote'));\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.compile(str));\n      cb(null, tmpl(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Toffee support.\n */\n\n\nexports.toffee = function (path, options, cb) {\n  return promisify(cb, function (cb) {\n    var toffee = requires.toffee || (requires.toffee = require('toffee'));\n\n    toffee.__consolidate_engine_render(path, options, cb);\n  });\n};\n/**\n * Toffee string support.\n */\n\n\nexports.toffee.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.toffee || (requires.toffee = require('toffee'));\n\n    try {\n      engine.str_render(str, options, cb);\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * doT support.\n */\n\n\nexports.dot = fromStringRenderer('dot');\n/**\n * doT string support.\n */\n\nexports.dot.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.dot || (requires.dot = require('dot'));\n\n    var extend = requires.extend || (requires.extend = require('util')._extend);\n\n    try {\n      var settings = {};\n      settings = extend(settings, engine.templateSettings);\n      settings = extend(settings, options ? options.dot : {});\n      var tmpl = cache(options) || cache(options, engine.template(str, settings, options));\n      cb(null, tmpl(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * bracket support.\n */\n\n\nexports.bracket = fromStringRenderer('bracket');\n/**\n * bracket string support.\n */\n\nexports.bracket.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.bracket || (requires.bracket = require('bracket-template'));\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.default.compile(str, options));\n      cb(null, tmpl(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Ractive support.\n */\n\n\nexports.ractive = fromStringRenderer('ractive');\n/**\n * Ractive string support.\n */\n\nexports.ractive.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var Engine = requires.ractive || (requires.ractive = require('ractive'));\n\n    var template = cache(options) || cache(options, Engine.parse(str));\n    options.template = template;\n\n    if (options.data === null || options.data === undefined) {\n      var extend = requires.extend || (requires.extend = require('util')._extend); // Shallow clone the options object\n\n\n      options.data = extend({}, options); // Remove consolidate-specific properties from the clone\n\n      var i;\n      var length;\n      var properties = ['template', 'filename', 'cache', 'partials'];\n\n      for (i = 0, length = properties.length; i < length; i++) {\n        var property = properties[i];\n        delete options.data[property];\n      }\n    }\n\n    try {\n      cb(null, new Engine(options).toHTML());\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Nunjucks support.\n */\n\n\nexports.nunjucks = fromStringRenderer('nunjucks');\n/**\n * Nunjucks string support.\n */\n\nexports.nunjucks.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    try {\n      var engine = options.nunjucksEnv || requires.nunjucks || (requires.nunjucks = require('nunjucks'));\n\n      var env = engine; // deprecated fallback support for express\n      // <https://github.com/tj/consolidate.js/pull/152>\n      // <https://github.com/tj/consolidate.js/pull/224>\n\n      if (options.settings && options.settings.views) {\n        env = engine.configure(options.settings.views);\n      } else if (options.nunjucks && options.nunjucks.configure) {\n        env = engine.configure.apply(engine, options.nunjucks.configure);\n      } //\n      // because `renderString` does not initiate loaders\n      // we must manually create a loader for it based off\n      // either `options.settings.views` or `options.nunjucks` or `options.nunjucks.root`\n      //\n      // <https://github.com/mozilla/nunjucks/issues/730>\n      // <https://github.com/crocodilejs/node-email-templates/issues/182>\n      //\n      // so instead we simply check if we passed a custom loader\n      // otherwise we create a simple file based loader\n\n\n      if (options.loader) {\n        env = new engine.Environment(options.loader);\n      } else if (options.settings && options.settings.views) {\n        env = new engine.Environment(new engine.FileSystemLoader(options.settings.views));\n      } else if (options.nunjucks && options.nunjucks.loader) {\n        if (typeof options.nunjucks.loader === 'string') {\n          env = new engine.Environment(new engine.FileSystemLoader(options.nunjucks.loader));\n        } else {\n          env = new engine.Environment(new engine.FileSystemLoader(options.nunjucks.loader[0], options.nunjucks.loader[1]));\n        }\n      }\n\n      env.renderString(str, options, cb);\n    } catch (err) {\n      throw cb(err);\n    }\n  });\n};\n/**\n * HTMLing support.\n */\n\n\nexports.htmling = fromStringRenderer('htmling');\n/**\n * HTMLing string support.\n */\n\nexports.htmling.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.htmling || (requires.htmling = require('htmling'));\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.string(str));\n      cb(null, tmpl.render(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n *  Rendering function\n */\n\n\nfunction requireReact(module, filename) {\n  var babel = requires.babel || (requires.babel = require('babel-core'));\n\n  var compiled = babel.transformFileSync(filename, {\n    presets: ['react']\n  }).code;\n  return module._compile(compiled, filename);\n}\n\nexports.requireReact = requireReact;\n/**\n *  Converting a string into a node module.\n */\n\nfunction requireReactString(src, filename) {\n  var babel = requires.babel || (requires.babel = require('babel-core'));\n\n  if (!filename) filename = '';\n  var m = new module.constructor();\n  filename = filename || ''; // Compile Using React\n\n  var compiled = babel.transform(src, {\n    presets: ['react']\n  }).code; // Compile as a module\n\n  m.paths = module.paths;\n\n  m._compile(compiled, filename);\n\n  return m.exports;\n}\n/**\n * A naive helper to replace {{tags}} with options.tags content\n */\n\n\nfunction reactBaseTmpl(data, options) {\n  var exp;\n  var regex; // Iterates through the keys in file object\n  // and interpolate / replace {{key}} with it's value\n\n  for (var k in options) {\n    if (options.hasOwnProperty(k)) {\n      exp = '{{' + k + '}}';\n      regex = new RegExp(exp, 'g');\n\n      if (data.match(regex)) {\n        data = data.replace(regex, options[k]);\n      }\n    }\n  }\n\n  return data;\n}\n/**\n* Plates Support.\n*/\n\n\nexports.plates = fromStringRenderer('plates');\n/**\n* Plates string support.\n*/\n\nexports.plates.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.plates || (requires.plates = require('plates'));\n\n    var map = options.map || undefined;\n\n    try {\n      var tmpl = engine.bind(str, options, map);\n      cb(null, tmpl);\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n *  The main render parser for React bsaed templates\n */\n\n\nfunction reactRenderer(type) {\n  if (require.extensions) {\n    // Ensure JSX is transformed on require\n    if (!require.extensions['.jsx']) {\n      require.extensions['.jsx'] = requireReact;\n    } // Supporting .react extension as well as test cases\n    // Using .react extension is not recommended.\n\n\n    if (!require.extensions['.react']) {\n      require.extensions['.react'] = requireReact;\n    }\n  } // Return rendering fx\n\n\n  return function (str, options, cb) {\n    return promisify(cb, function (cb) {\n      // React Import\n      var ReactDOM = requires.ReactDOM || (requires.ReactDOM = require('react-dom/server'));\n\n      var react = requires.react || (requires.react = require('react')); // Assign HTML Base\n\n\n      var base = options.base;\n      delete options.base;\n      var enableCache = options.cache;\n      delete options.cache;\n      var isNonStatic = options.isNonStatic;\n      delete options.isNonStatic; // Start Conversion\n\n      try {\n        var Code;\n        var Factory;\n        var baseStr;\n        var content;\n        var parsed;\n\n        if (!cache(options)) {\n          // Parsing\n          if (type === 'path') {\n            var path = resolve(str);\n            delete require.cache[path];\n            Code = require(path);\n          } else {\n            Code = requireReactString(str);\n          }\n\n          Factory = cache(options, react.createFactory(Code));\n        } else {\n          Factory = cache(options);\n        }\n\n        parsed = new Factory(options);\n        content = isNonStatic ? ReactDOM.renderToString(parsed) : ReactDOM.renderToStaticMarkup(parsed);\n\n        if (base) {\n          baseStr = readCache[str] || fs.readFileSync(resolve(base), 'utf8');\n\n          if (enableCache) {\n            readCache[str] = baseStr;\n          }\n\n          options.content = content;\n          content = reactBaseTmpl(baseStr, options);\n        }\n\n        cb(null, content);\n      } catch (err) {\n        cb(err);\n      }\n    });\n  };\n}\n/**\n * React JS Support\n */\n\n\nexports.react = reactRenderer('path');\n/**\n * React JS string support.\n */\n\nexports.react.render = reactRenderer('string');\n/**\n * ARC-templates support.\n */\n\nexports['arc-templates'] = fromStringRenderer('arc-templates');\n/**\n * ARC-templates string support.\n */\n\nexports['arc-templates'].render = function (str, options, cb) {\n  var readFileWithOptions = Promise.promisify(read);\n  var consolidateFileSystem = {};\n\n  consolidateFileSystem.readFile = function (path) {\n    return readFileWithOptions(path, options);\n  };\n\n  return promisify(cb, function (cb) {\n    try {\n      var engine = requires['arc-templates'];\n\n      if (!engine) {\n        var Engine = require('arc-templates/dist/es5');\n\n        engine = requires['arc-templates'] = new Engine({\n          filesystem: consolidateFileSystem\n        });\n      }\n\n      var compiler = cache(options) || cache(options, engine.compileString(str, options.filename));\n      compiler.then(function (func) {\n        return func(options);\n      }).then(function (result) {\n        cb(null, result.content);\n      }).catch(cb);\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Vash support\n */\n\n\nexports.vash = fromStringRenderer('vash');\n/**\n * Vash string support\n */\n\nexports.vash.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.vash || (requires.vash = require('vash'));\n\n    try {\n      // helper system : https://github.com/kirbysayshi/vash#helper-system\n      if (options.helpers) {\n        for (var key in options.helpers) {\n          if (!options.helpers.hasOwnProperty(key) || typeof options.helpers[key] !== 'function') {\n            continue;\n          }\n\n          engine.helpers[key] = options.helpers[key];\n        }\n      }\n\n      var tmpl = cache(options) || cache(options, engine.compile(str, options));\n      tmpl(options, function sealLayout(err, ctx) {\n        if (err) cb(err);\n        ctx.finishLayout();\n        cb(null, ctx.toString().replace(/\\n$/, ''));\n      });\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Slm support.\n */\n\n\nexports.slm = fromStringRenderer('slm');\n/**\n * Slm string support.\n */\n\nexports.slm.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.slm || (requires.slm = require('slm'));\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.compile(str, options));\n      cb(null, tmpl(options));\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Marko support.\n */\n\n\nexports.marko = function (path, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.marko || (requires.marko = require('marko'));\n\n    options.writeToDisk = !!options.cache;\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.load(path, options));\n      tmpl.renderToString(options, cb);\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Marko string support.\n */\n\n\nexports.marko.render = function (str, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.marko || (requires.marko = require('marko'));\n\n    options.writeToDisk = !!options.cache;\n    options.filename = options.filename || 'string.marko';\n\n    try {\n      var tmpl = cache(options) || cache(options, engine.load(options.filename, str, options));\n      tmpl.renderToString(options, cb);\n    } catch (err) {\n      cb(err);\n    }\n  });\n};\n/**\n * Teacup support.\n */\n\n\nexports.teacup = function (path, options, cb) {\n  return promisify(cb, function (cb) {\n    var engine = requires.teacup || (requires.teacup = require('teacup/lib/express'));\n\n    require.extensions['.teacup'] = require.extensions['.coffee'];\n\n    if (path[0] !== '/') {\n      path = join(process.cwd(), path);\n    }\n\n    if (!options.cache) {\n      var callback = cb;\n\n      cb = function cb() {\n        delete require.cache[path];\n        callback.apply(this, arguments);\n      };\n    }\n\n    engine.renderFile(path, options, cb);\n  });\n};\n/**\n * Teacup string support.\n */\n\n\nexports.teacup.render = function (str, options, cb) {\n  var coffee = require('coffee-script');\n\n  var vm = require('vm');\n\n  var sandbox = {\n    module: {\n      exports: {}\n    },\n    require: require\n  };\n  return promisify(cb, function (cb) {\n    vm.runInNewContext(coffee.compile(str), sandbox);\n    var tmpl = sandbox.module.exports;\n    cb(null, tmpl(options));\n  });\n};\n/**\n * expose the instance of the engine\n */\n\n\nexports.requires = requires;","map":null,"metadata":{},"sourceType":"script"}